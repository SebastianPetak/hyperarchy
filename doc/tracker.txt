* when a ranking is created / updated / destroyed, recompute the vote tally
election.ranked/unranked candidates must be by user
test the view extension's ability to get back to the view wrapper from a new jquery wrapper of an element
ranking removal x is only visible when a candidate is ranked and hovered over
release foundation.js
implement auto code reloading for the server-side code in development
candidates can be unranked when the x is clicked and return to the unranked candidates list
rename candidates view to unranked_candidates
make Server.fetch take varargs as well as arrays
if current user is null, direct to login screen always
cache the results of fetching the same relation twice within a short period of time
replace _.defer in initialize with onDomAttach hook
add _ to the closure surrounding every monarch file
attempt to convert comet hub to use the cramp library
secure the ranking api against unauthorized writes
refactor client side list code into a single generic widget
add the suite keyword to screw unit so that hyperarchy and monarch spec suites can be run together on a single page
when a constructor is declared with the same name as an extant module, extend the constructor with the module
test :class_name option to belongs_to

add a _._ underscore builder object which builds views with a single top-level method call _._li({candidateId: "foo"});
convert screw unit to use underscore.js _.isEqual for equal matcher?
document and release screw unit
make relations work with beEmpty matcher, possibly by tying into or creating some general underscore facility for determining emptyness
rename table.globalName to name
support for anonymous modules in foundation.js
add a limit operator to the server side and use it for Relation#first

deferred issues / open questions
---------------
should Record#update allow id to be assigned?
when an update is performed on a relation, records in the identity map can become stale. should I implement relation#reload for relations that have records (not just tuples), which reloads any records in the id map? could be expensive. may want to implement in memory?
checking for the existence of the session every single request? shouldn't that at least cache it in the identity map?
should exposed repository be in the http package, so nothing in model is dependent on http?
what to do if creating an object fails with an error? call error callback? should the element be in the local repository
